# 第 5 章: 代码规范

## 5.1 Python 风格规范

### 5.1.1 PEP 8 规范

严格遵循 PEP 8 编码规范:

```python
# 好的示例
def calculate_download_speed(file_size, duration):
    """计算下载速度

    Args:
        file_size: 文件大小(字节)
        duration: 下载耗时(秒)

    Returns:
        float: 下载速度(MB/s)
    """
    if duration <= 0:
        return 0.0

    speed = file_size / (1024 * 1024) / duration
    return speed


# 不好的示例
def calcSpeed(size, time):
    s=size/(1024*1024)/time
    return s
```

### 5.1.2 代码格式化

使用 black 进行代码格式化:

```bash
# 安装black
pip install black

# 格式化代码
black src/

# 检查格式(不修改文件)
black --check src/

# 配置pyproject.toml
[tool.black]
line-length = 88
target-version = ['py38']
include = '\.pyi?$'
extend-exclude = '''
/(
  # 排除目录
  \.eggs
  | \.git
  | \.venv
  | build
  | dist
)/
'''
```

### 5.1.3 导入排序

使用 isort 进行导入排序:

```bash
# 安装isort
pip install isort

# 排序导入
isort src/

# 检查导入(不修改文件)
isort --check-only src/

# 配置pyproject.toml
[tool.isort]
profile = "black"
line_length = 88
multi_line_output = 3
include_trailing_comma = true
force_grid_wrap = 0
use_parentheses = true
ensure_newline_before_comments = true
```

### 5.1.4 类型检查

使用 mypy 进行类型检查:

```bash
# 安装mypy
pip install mypy

# 类型检查
mypy src/

# 配置mypy.ini
[mypy]
python_version = 3.8
warn_return_any = true
warn_unused_configs = true
disallow_untyped_defs = true
ignore_missing_imports = true

[mypy-tests.*]
disallow_untyped_defs = false
```

类型注解示例:

```python
from typing import Dict, List, Optional, Tuple
from pathlib import Path

class DownloadManager:
    """下载管理器"""

    def __init__(self, max_retries: int = 3, timeout: int = 30) -> None:
        """初始化下载管理器

        Args:
            max_retries: 最大重试次数
            timeout: 超时时间(秒)
        """
        self.max_retries = max_retries
        self.timeout = timeout

    def download_segment(
        self,
        url: str,
        output_path: str,
        headers: Optional[Dict[str, str]] = None
    ) -> bool:
        """下载视频分片

        Args:
            url: 分片URL
            output_path: 输出文件路径
            headers: 请求头

        Returns:
            bool: 下载是否成功
        """
        try:
            response = requests.get(url, headers=headers, timeout=self.timeout)
            response.raise_for_status()

            Path(output_path).parent.mkdir(parents=True, exist_ok=True)
            Path(output_path).write_bytes(response.content)

            return True
        except Exception as e:
            print(f"下载失败: {e}")
            return False

    def download_all_segments(
        self,
        segment_urls: List[str],
        output_dir: str
    ) -> Tuple[int, int]:
        """下载所有分片

        Args:
            segment_urls: 分片URL列表
            output_dir: 输出目录

        Returns:
            Tuple[int, int]: (成功数量, 失败数量)
        """
        success_count = 0
        failure_count = 0

        for i, url in enumerate(segment_urls):
            output_path = f"{output_dir}/segment_{i:04d}.ts"
            if self.download_segment(url, output_path):
                success_count += 1
            else:
                failure_count += 1

        return success_count, failure_count
```

## 5.2 模块化设计

### 5.2.1 单一职责原则

每个模块应该只有一个改变的理由:

```python
# 好的设计 - 单一职责
class CookieManager:
    """专门负责Cookie管理"""
    pass

class URLParser:
    """专门负责URL解析"""
    pass

class DownloadManager:
    """专门负责下载管理"""
    pass

class VideoMerger:
    """专门负责视频合并"""
    pass

# 不好的设计 - 职责过多
class AllInOneManager:
    """管理所有功能 - 违反单一职责原则"""
    def manage_cookies(self):
        pass

    def parse_url(self):
        pass

    def download(self):
        pass

    def merge_video(self):
        pass
```

### 5.2.2 模块依赖关系

保持清晰的模块依赖关系,避免循环依赖:

```python
# 模块结构
src/
├── __init__.py
├── cookie_manager.py      # Cookie管理
├── url_parser.py          # URL解析
├── download_manager.py    # 下载管理
├── video_merger.py        # 视频合并
├── file_manager.py        # 文件管理
├── config_manager.py      # 配置管理
├── auth_manager.py        # 鉴权管理
├── logger.py              # 日志系统
└── exceptions.py         # 异常定义

# 依赖关系
# cookie_manager.py (无依赖)
# url_parser.py (无依赖)
# exceptions.py (无依赖)
# logger.py (无依赖)
# download_manager.py (依赖: cookie_manager, url_parser, exceptions, logger)
# video_merger.py (依赖: logger, exceptions)
# file_manager.py (依赖: logger, exceptions)
# config_manager.py (无依赖)
# auth_manager.py (依赖: cookie_manager, logger, exceptions)
```

### 5.2.3 接口设计

定义清晰的接口契约:

```python
from abc import ABC, abstractmethod
from typing import Dict, Optional

class IDownloader(ABC):
    """下载器接口"""

    @abstractmethod
    def download(self, url: str, output_path: str) -> bool:
        """下载文件

        Args:
            url: 文件URL
            output_path: 输出文件路径

        Returns:
            bool: 下载是否成功
        """
        pass

    @abstractmethod
    def get_progress(self) -> float:
        """获取下载进度

        Returns:
            float: 进度百分比(0.0-1.0)
        """
        pass


class HttpDownloader(IDownloader):
    """HTTP下载器实现"""

    def __init__(self, timeout: int = 30):
        self.timeout = timeout
        self._progress = 0.0

    def download(self, url: str, output_path: str) -> bool:
        """实现HTTP下载"""
        try:
            import requests
            response = requests.get(url, timeout=self.timeout)
            response.raise_for_status()

            Path(output_path).parent.mkdir(parents=True, exist_ok=True)
            Path(output_path).write_bytes(response.content)

            self._progress = 1.0
            return True
        except Exception as e:
            print(f"下载失败: {e}")
            return False

    def get_progress(self) -> float:
        """获取进度"""
        return self._progress
```

## 5.3 命名规范

### 5.3.1 变量命名

使用描述性的变量名:

```python
# 好的命名
download_speed = calculate_speed(file_size, duration)
max_retry_count = 3
cookie_file_path = "./cookies/cookies.json"
video_segments = []

# 不好的命名
s = calc_speed(fs, d)
n = 3
path = "./cookies/cookies.json"
segments = []
```

### 5.3.2 函数命名

使用动词或动词短语:

```python
# 好的命名
def download_segment(url: str, output_path: str) -> bool:
    pass

def parse_video_url(url: str) -> Dict:
    pass

def merge_video_files(segment_files: List[str], output_file: str) -> bool:
    pass

def save_cookies(cookies: Dict, file_path: str) -> None:
    pass

# 不好的命名
def segment(url, path):
    pass

def url(url):
    pass

def merge(files, output):
    pass

def save(cookies, path):
    pass
```

### 5.3.3 类命名

使用名词,首字母大写:

```python
# 好的命名
class CookieManager:
    pass

class URLParser:
    pass

class DownloadManager:
    pass

class VideoMerger:
    pass

# 不好的命名
class cookieManager:
    pass

class url_parser:
    pass

class download:
    pass
```

### 5.3.4 常量命名

使用全大写,下划线分隔:

```python
# 好的命名
MAX_RETRY_COUNT = 3
DEFAULT_TIMEOUT = 30
COOKIE_FILE_PATH = "./cookies/cookies.json"
DOWNLOAD_THREADS = 4

# 不好的命名
max_retry = 3
timeout = 30
cookie_path = "./cookies/cookies.json"
threads = 4
```

## 5.4 文档要求

### 5.4.1 模块文档字符串

每个模块都应该有文档字符串:

```python
"""
Cookie管理模块

该模块提供Cookie的读取、保存、删除等功能。
支持从文件加载Cookie,并自动管理Cookie的过期时间。

主要类:
    CookieManager: Cookie管理器类

主要函数:
    load_cookies_from_file: 从文件加载Cookie
    save_cookies_to_file: 保存Cookie到文件

示例:
    >>> from cookie_manager import CookieManager
    >>> manager = CookieManager("./cookies/cookies.json")
    >>> manager.save_cookie("example.com", {"session": "abc123"})
    >>> cookie = manager.load_cookie("example.com")
    >>> print(cookie)
    {'session': 'abc123'}
"""

from typing import Dict, Optional
import json
from pathlib import Path
import os

class CookieManager:
    """Cookie管理器"""
    pass
```

### 5.4.2 类文档字符串

使用 Google 风格的文档字符串:

```python
class CookieManager:
    """Cookie管理器

    该类提供Cookie的读取、保存、删除等功能。
    支持从JSON文件加载和保存Cookie。

    Attributes:
        cookie_file: Cookie文件路径
        cookies: Cookie字典,键为域名,值为Cookie数据

    Examples:
        >>> manager = CookieManager("./cookies/cookies.json")
        >>> manager.save_cookie("example.com", {"session": "abc123"})
        >>> cookie = manager.load_cookie("example.com")
        >>> print(cookie)
        {'session': 'abc123'}
    """

    def __init__(self, cookie_file: str = "./cookies/cookies.json"):
        """初始化Cookie管理器

        Args:
            cookie_file: Cookie文件路径,默认为"./cookies/cookies.json"

        Raises:
            FileNotFoundError: 如果Cookie文件不存在且无法创建
        """
        self.cookie_file = cookie_file
        self.cookies: Dict[str, Dict] = {}
        self._ensure_cookie_dir()
        self._load_cookies()

    def save_cookie(self, domain: str, cookie_data: Dict) -> None:
        """保存Cookie

        将Cookie数据保存到内存和文件中。

        Args:
            domain: 域名
            cookie_data: Cookie数据字典

        Raises:
            IOError: 如果写入文件失败

        Examples:
            >>> manager = CookieManager()
            >>> manager.save_cookie("example.com", {"session": "abc123"})
        """
        self.cookies[domain] = cookie_data
        self._save_to_file()
```

### 5.4.3 日志记录规范

日志记录规范详见 [3.2.3 日志记录规范](../钉钉直播回放下载软件开发指南-第3章.md#3.2.3-日志记录规范)。

### 5.4.4 代码注释

注释应该解释"为什么",而不是"是什么":

```python
# 好的注释 - 解释为什么
# 使用指数退避策略避免服务器过载
delay = 2 ** attempt

# 不好的注释 - 重复代码
# 计算延迟时间
delay = 2 ** attempt


# 好的注释 - 解释设计决策
# 使用JSON格式存储Cookie,便于人工编辑和调试
cookie_file = "./cookies/cookies.json"

# 不好的注释 - 无意义
# Cookie文件
cookie_file = "./cookies/cookies.json"


# 好的注释 - 解释复杂逻辑
# 检查Cookie是否过期,过期则删除
if cookie.get('expires', 0) < current_timestamp:
    self.delete_cookie(domain)

# 不好的注释 - 重复代码
# 如果过期时间小于当前时间,删除Cookie
if cookie.get('expires', 0) < current_timestamp:
    self.delete_cookie(domain)
```

## 5.5 代码质量检查

### 5.5.1 使用 flake8

```bash
# 安装flake8
pip install flake8

# 检查代码
flake8 src/

# 配置.flake8
[flake8]
max-line-length = 88
extend-ignore = E203, W503
exclude =
    .git,
    __pycache__,
    .venv,
    build,
    dist
```

### 5.5.2 使用 pylint

```bash
# 安装pylint
pip install pylint

# 检查代码
pylint src/

# 配置pylintrc
[MASTER]
disable=
    C0111,  # missing-docstring
    C0103,  # invalid-name
    R0903,  # too-few-public-methods

[FORMAT]
max-line-length=88
```

### 5.5.3 使用 pre-commit 钩子

配置`.pre-commit-config.yaml`:

```yaml
repos:
  - repo: https://github.com/psf/black
    rev: 22.3.0
    hooks:
      - id: black

  - repo: https://github.com/PyCQA/isort
    rev: 5.10.1
    hooks:
      - id: isort

  - repo: https://github.com/PyCQA/flake8
    rev: 4.0.1
    hooks:
      - id: flake8

  - repo: https://github.com/pre-commit/mirrors-mypy
    rev: v0.942
    hooks:
      - id: mypy
        additional_dependencies: [types-all]
```

安装 pre-commit 钩子:

```bash
# 安装pre-commit
pip install pre-commit

# 安装钩子
pre-commit install

# 手动运行
pre-commit run --all-files
```

## 5.6 代码审查清单

### 5.6.1 功能性检查

- [ ] 代码是否实现了所有需求功能
- [ ] 边界条件是否正确处理
- [ ] 错误处理是否完善
- [ ] 是否有内存泄漏风险
- [ ] 是否有线程安全问题

### 5.6.2 可读性检查

- [ ] 变量和函数命名是否清晰
- [ ] 代码结构是否合理
- [ ] 是否有复杂的嵌套逻辑
- [ ] 注释是否准确且必要
- [ ] 是否有重复代码

### 5.6.3 性能检查

- [ ] 是否有不必要的对象创建
- [ ] 是否有重复计算
- [ ] 是否使用了合适的数据结构
- [ ] 是否有性能瓶颈
- [ ] 是否需要优化算法

### 5.6.4 安全性检查

- [ ] 是否有 SQL 注入风险
- [ ] 是否有 XSS 攻击风险
- [ ] 是否有敏感信息泄露
- [ ] 是否有权限控制问题
- [ ] 是否有输入验证

### 5.6.5 测试检查

- [ ] 是否有单元测试
- [ ] 测试覆盖率是否达标
- [ ] 是否有集成测试
- [ ] 是否有边界测试
- [ ] 是否有异常测试

## 5.7 重构建议

### 5.7.1 提取函数

当函数过长时,提取子函数:

```python
# 重构前
def process_video(url: str, output_dir: str) -> bool:
    """处理视频"""
    # 解析URL
    parsed = urlparse(url)
    video_id = parsed.path.split('/')[-1]

    # 下载分片
    segments = []
    for i in range(10):
        segment_url = f"{parsed.scheme}://{parsed.netloc}/segments/{video_id}_{i}.ts"
        response = requests.get(segment_url)
        if response.status_code == 200:
            segment_file = f"{output_dir}/segment_{i}.ts"
            Path(segment_file).write_bytes(response.content)
            segments.append(segment_file)

    # 合并视频
    output_file = f"{output_dir}/{video_id}.mp4"
    with open(output_file, 'wb') as outfile:
        for segment in segments:
            with open(segment, 'rb') as infile:
                outfile.write(infile.read())

    return True

# 重构后
def process_video(url: str, output_dir: str) -> bool:
    """处理视频"""
    video_id = extract_video_id(url)
    segments = download_segments(url, video_id, output_dir)
    return merge_segments(segments, output_dir, video_id)

def extract_video_id(url: str) -> str:
    """提取视频ID"""
    parsed = urlparse(url)
    return parsed.path.split('/')[-1]

def download_segments(url: str, video_id: str, output_dir: str) -> List[str]:
    """下载所有分片"""
    parsed = urlparse(url)
    segments = []

    for i in range(10):
        segment_url = f"{parsed.scheme}://{parsed.netloc}/segments/{video_id}_{i}.ts"
        response = requests.get(segment_url)

        if response.status_code == 200:
            segment_file = f"{output_dir}/segment_{i}.ts"
            Path(segment_file).write_bytes(response.content)
            segments.append(segment_file)

    return segments

def merge_segments(segments: List[str], output_dir: str, video_id: str) -> bool:
    """合并分片"""
    output_file = f"{output_dir}/{video_id}.mp4"

    with open(output_file, 'wb') as outfile:
        for segment in segments:
            with open(segment, 'rb') as infile:
                outfile.write(infile.read())

    return True
```

### 5.7.2 提取类

当类职责过多时,提取新类:

```python
# 重构前
class DownloadManager:
    """下载管理器"""

    def __init__(self):
        self.cookies = {}
        self.max_retries = 3
        self.timeout = 30

    def save_cookie(self, domain: str, cookie_data: Dict):
        """保存Cookie"""
        self.cookies[domain] = cookie_data

    def load_cookie(self, domain: str) -> Optional[Dict]:
        """加载Cookie"""
        return self.cookies.get(domain)

    def download_segment(self, url: str, output_path: str) -> bool:
        """下载分片"""
        pass

    def merge_video(self, segments: List[str], output_file: str) -> bool:
        """合并视频"""
        pass

# 重构后
class CookieManager:
    """Cookie管理器"""

    def __init__(self):
        self.cookies = {}

    def save_cookie(self, domain: str, cookie_data: Dict):
        """保存Cookie"""
        self.cookies[domain] = cookie_data

    def load_cookie(self, domain: str) -> Optional[Dict]:
        """加载Cookie"""
        return self.cookies.get(domain)

class DownloadManager:
    """下载管理器"""

    def __init__(self, cookie_manager: CookieManager):
        self.cookie_manager = cookie_manager
        self.max_retries = 3
        self.timeout = 30

    def download_segment(self, url: str, output_path: str) -> bool:
        """下载分片"""
        pass

class VideoMerger:
    """视频合并器"""

    def merge_video(self, segments: List[str], output_file: str) -> bool:
        """合并视频"""
        pass
```

### 5.7.3 使用策略模式

当有多种算法实现时,使用策略模式:

```python
# 重构前
class DownloadManager:
    """下载管理器"""

    def __init__(self):
        self.max_retries = 3
        self.timeout = 30

    def download_with_retry(self, url: str, output_path: str) -> bool:
        """带重试的下载"""
        for attempt in range(self.max_retries):
            if self._download(url, output_path):
                return True
            time.sleep(2 ** attempt)
        return False

    def download_without_retry(self, url: str, output_path: str) -> bool:
        """不带重试的下载"""
        return self._download(url, output_path)

    def _download(self, url: str, output_path: str) -> bool:
        """实际下载逻辑"""
        pass

# 重构后
class DownloadStrategy(ABC):
    """下载策略接口"""

    @abstractmethod
    def download(self, url: str, output_path: str) -> bool:
        """下载"""
        pass

class RetryDownloadStrategy(DownloadStrategy):
    """带重试的下载策略"""

    def __init__(self, max_retries: int = 3):
        self.max_retries = max_retries

    def download(self, url: str, output_path: str) -> bool:
        """带重试的下载"""
        for attempt in range(self.max_retries):
            if self._download(url, output_path):
                return True
            time.sleep(2 ** attempt)
        return False

    def _download(self, url: str, output_path: str) -> bool:
        """实际下载逻辑"""
        pass

class SimpleDownloadStrategy(DownloadStrategy):
    """简单下载策略"""

    def download(self, url: str, output_path: str) -> bool:
        """简单下载"""
        return self._download(url, output_path)

    def _download(self, url: str, output_path: str) -> bool:
        """实际下载逻辑"""
        pass

class DownloadManager:
    """下载管理器"""

    def __init__(self, strategy: DownloadStrategy):
        self.strategy = strategy

    def download(self, url: str, output_path: str) -> bool:
        """下载"""
        return self.strategy.download(url, output_path)
```
