# 第4章: 测试与验证

## 4.1 单元测试

### 4.1.1 测试框架配置

使用pytest作为测试框架,配置文件`pytest.ini`:

```ini
[pytest]
testpaths = tests
python_files = test_*.py
python_classes = Test*
python_functions = test_*
addopts = 
    --verbose
    --strict-markers
    --cov=src
    --cov-report=html
    --cov-report=term-missing
    --cov-fail-under=80
markers =
    slow: marks tests as slow
    integration: marks tests as integration tests
```

### 4.1.2 CookieManager单元测试

```python
import pytest
import json
import os
from pathlib import Path
from src.cookie_manager import CookieManager

class TestCookieManager:
    """Cookie管理器单元测试"""
    
    @pytest.fixture
    def cookie_file(self, tmp_path):
        """创建临时Cookie文件"""
        return tmp_path / "cookies.json"
    
    @pytest.fixture
    def cookie_manager(self, cookie_file):
        """创建Cookie管理器实例"""
        return CookieManager(str(cookie_file))
    
    def test_init_creates_cookie_dir(self, cookie_file):
        """测试初始化时创建Cookie目录"""
        manager = CookieManager(str(cookie_file))
        cookie_dir = Path(cookie_file).parent
        assert cookie_dir.exists()
    
    def test_save_cookie(self, cookie_manager, cookie_file):
        """测试保存Cookie"""
        cookie_data = {"name": "session", "value": "test123"}
        cookie_manager.save_cookie("test.com", cookie_data)
        
        assert "test.com" in cookie_manager.cookies
        assert cookie_manager.cookies["test.com"] == cookie_data
        
        # 验证文件保存
        with open(cookie_file, 'r', encoding='utf-8') as f:
            saved_data = json.load(f)
        assert "test.com" in saved_data
    
    def test_load_cookie(self, cookie_manager, cookie_file):
        """测试加载Cookie"""
        cookie_data = {"name": "session", "value": "test123"}
        
        # 先保存
        cookie_manager.save_cookie("test.com", cookie_data)
        
        # 创建新实例加载
        new_manager = CookieManager(str(cookie_file))
        loaded_cookie = new_manager.load_cookie("test.com")
        
        assert loaded_cookie == cookie_data
    
    def test_load_cookie_not_found(self, cookie_manager):
        """测试加载不存在的Cookie"""
        result = cookie_manager.load_cookie("notfound.com")
        assert result is None
    
    def test_delete_cookie(self, cookie_manager, cookie_file):
        """测试删除Cookie"""
        cookie_data = {"name": "session", "value": "test123"}
        cookie_manager.save_cookie("test.com", cookie_data)
        
        cookie_manager.delete_cookie("test.com")
        
        assert "test.com" not in cookie_manager.cookies
        
        # 验证文件更新
        with open(cookie_file, 'r', encoding='utf-8') as f:
            saved_data = json.load(f)
        assert "test.com" not in saved_data
    
    def test_clear_all_cookies(self, cookie_manager, cookie_file):
        """测试清空所有Cookie"""
        cookie_manager.save_cookie("test1.com", {"name": "session1"})
        cookie_manager.save_cookie("test2.com", {"name": "session2"})
        
        cookie_manager.clear_all()
        
        assert len(cookie_manager.cookies) == 0
        
        # 验证文件清空
        with open(cookie_file, 'r', encoding='utf-8') as f:
            saved_data = json.load(f)
        assert len(saved_data) == 0
```

### 4.1.3 URLParser单元测试

```python
import pytest
from src.url_parser import URLParser

class TestURLParser:
    """URL解析器单元测试"""
    
    @pytest.fixture
    def parser(self):
        """创建URL解析器实例"""
        return URLParser()
    
    def test_parse_valid_url(self, parser):
        """测试解析有效的URL"""
        url = "https://dtlive-prod.dingtalk.com/live_hls/12345.m3u8?auth_key=abc123"
        result = parser.parse(url)
        
        assert result is not None
        assert result["domain"] == "dtlive-prod.dingtalk.com"
        assert result["path"] == "/live_hls/12345.m3u8"
        assert "auth_key" in result["params"]
    
    def test_parse_invalid_url(self, parser):
        """测试解析无效的URL"""
        url = "not_a_valid_url"
        result = parser.parse(url)
        
        assert result is None
    
    def test_extract_auth_params(self, parser):
        """测试提取认证参数"""
        url = "https://example.com/video.m3u8?auth_key=abc&expires=123"
        result = parser.parse(url)
        
        assert result["params"]["auth_key"] == "abc"
        assert result["params"]["expires"] == "123"
    
    def test_extract_video_id(self, parser):
        """测试提取视频ID"""
        url = "https://dtlive-prod.dingtalk.com/live_hls/12345.m3u8"
        result = parser.parse(url)
        
        assert result["video_id"] == "12345"
```

### 4.1.4 DownloadManager单元测试

```python
import pytest
from unittest.mock import Mock, patch
from src.download_manager import DownloadManager

class TestDownloadManager:
    """下载管理器单元测试"""
    
    @pytest.fixture
    def download_manager(self):
        """创建下载管理器实例"""
        return DownloadManager()
    
    @patch('requests.get')
    def test_download_segment_success(self, mock_get, download_manager):
        """测试成功下载分片"""
        mock_response = Mock()
        mock_response.status_code = 200
        mock_response.content = b"test content"
        mock_get.return_value = mock_response
        
        url = "https://example.com/segment1.ts"
        result = download_manager.download_segment(url, "temp.ts")
        
        assert result is True
        assert os.path.exists("temp.ts")
        mock_get.assert_called_once()
        
        # 清理
        os.remove("temp.ts")
    
    @patch('requests.get')
    def test_download_segment_failure(self, mock_get, download_manager):
        """测试下载分片失败"""
        mock_response = Mock()
        mock_response.status_code = 404
        mock_get.return_value = mock_response
        
        url = "https://example.com/segment1.ts"
        result = download_manager.download_segment(url, "temp.ts")
        
        assert result is False
        assert not os.path.exists("temp.ts")
    
    def test_calculate_retry_delay(self, download_manager):
        """测试计算重试延迟"""
        delay1 = download_manager.calculate_retry_delay(1)
        delay2 = download_manager.calculate_retry_delay(2)
        delay3 = download_manager.calculate_retry_delay(3)
        
        assert delay1 < delay2 < delay3
```

## 4.2 集成测试

### 4.2.1 完整下载流程测试

```python
import pytest
from pathlib import Path
from src.cookie_manager import CookieManager
from src.url_parser import URLParser
from src.download_manager import DownloadManager
from src.video_merger import VideoMerger

@pytest.mark.integration
class TestDownloadWorkflow:
    """完整下载流程集成测试"""
    
    @pytest.fixture
    def cookie_manager(self, tmp_path):
        """创建Cookie管理器"""
        cookie_file = tmp_path / "cookies.json"
        return CookieManager(str(cookie_file))
    
    @pytest.fixture
    def url_parser(self):
        """创建URL解析器"""
        return URLParser()
    
    @pytest.fixture
    def download_manager(self):
        """创建下载管理器"""
        return DownloadManager()
    
    @pytest.fixture
    def video_merger(self):
        """创建视频合并器"""
        return VideoMerger()
    
    def test_complete_download_workflow(self, cookie_manager, url_parser, 
                                        download_manager, video_merger, tmp_path):
        """测试完整下载流程"""
        # 1. 准备Cookie
        cookie_data = {"name": "session", "value": "test123"}
        cookie_manager.save_cookie("dingtalk.com", cookie_data)
        
        # 2. 解析URL
        test_url = "https://dtlive-prod.dingtalk.com/live_hls/test123.m3u8"
        parsed_url = url_parser.parse(test_url)
        
        assert parsed_url is not None
        assert parsed_url["video_id"] == "test123"
        
        # 3. 模拟下载分片
        segments_dir = tmp_path / "segments"
        segments_dir.mkdir()
        
        for i in range(3):
            segment_file = segments_dir / f"segment{i}.ts"
            segment_file.write_bytes(f"segment{i} content".encode())
        
        # 4. 合并视频
        output_file = tmp_path / "output.mp4"
        
        # 注意: 实际测试时需要模拟或使用真实的ffmpeg
        # 这里仅展示测试结构
        assert segments_dir.exists()
        assert len(list(segments_dir.glob("*.ts"))) == 3
```

### 4.2.2 错误恢复测试

```python
@pytest.mark.integration
class TestErrorRecovery:
    """错误恢复集成测试"""
    
    @pytest.fixture
    def download_manager(self):
        """创建下载管理器"""
        return DownloadManager()
    
    def test_download_with_retry(self, download_manager, tmp_path):
        """测试带重试的下载"""
        segments_dir = tmp_path / "segments"
        segments_dir.mkdir()
        
        # 模拟前两次失败,第三次成功
        attempt_count = [0]
        
        def mock_download(url, output_path):
            attempt_count[0] += 1
            if attempt_count[0] < 3:
                return False
            Path(output_path).write_bytes(b"success")
            return True
        
        # 使用mock下载函数
        result = mock_download("https://example.com/segment.ts", 
                              str(segments_dir / "segment.ts"))
        
        assert result is True
        assert (segments_dir / "segment.ts").exists()
```

## 4.3 性能测试

### 4.3.1 下载速度测试

```python
import pytest
import time
from src.download_manager import DownloadManager

@pytest.mark.slow
class TestPerformance:
    """性能测试"""
    
    @pytest.fixture
    def download_manager(self):
        """创建下载管理器"""
        return DownloadManager()
    
    def test_download_speed(self, download_manager, tmp_path):
        """测试下载速度"""
        output_file = tmp_path / "test_segment.ts"
        
        # 模拟下载
        start_time = time.time()
        
        # 创建测试文件
        test_data = b"x" * (10 * 1024 * 1024)  # 10MB
        output_file.write_bytes(test_data)
        
        end_time = time.time()
        duration = end_time - start_time
        
        # 计算速度 (MB/s)
        speed = len(test_data) / (1024 * 1024) / duration
        
        # 验证速度合理 (至少1MB/s)
        assert speed >= 1.0, f"下载速度过低: {speed:.2f} MB/s"
    
    def test_concurrent_download(self, download_manager, tmp_path):
        """测试并发下载"""
        import concurrent.futures
        
        segments_dir = tmp_path / "segments"
        segments_dir.mkdir()
        
        def download_segment(i):
            segment_file = segments_dir / f"segment{i}.ts"
            segment_file.write_bytes(f"segment{i}".encode())
            return True
        
        # 并发下载10个分片
        start_time = time.time()
        
        with concurrent.futures.ThreadPoolExecutor(max_workers=5) as executor:
            futures = [executor.submit(download_segment, i) for i in range(10)]
            results = [f.result() for f in futures]
        
        end_time = time.time()
        duration = end_time - start_time
        
        assert all(results)
        assert len(list(segments_dir.glob("*.ts"))) == 10
        
        # 并发下载应该比串行快
        print(f"并发下载10个分片耗时: {duration:.2f}秒")
```

### 4.3.2 内存使用测试

```python
import pytest
import psutil
import os

@pytest.mark.slow
class TestMemoryUsage:
    """内存使用测试"""
    
    def test_memory_efficiency(self, tmp_path):
        """测试内存效率"""
        process = psutil.Process(os.getpid())
        
        # 记录初始内存
        initial_memory = process.memory_info().rss / 1024 / 1024  # MB
        
        # 创建大量分片文件
        segments_dir = tmp_path / "segments"
        segments_dir.mkdir()
        
        for i in range(100):
            segment_file = segments_dir / f"segment{i}.ts"
            segment_file.write_bytes(b"x" * 1024 * 1024)  # 1MB
        
        # 记录峰值内存
        peak_memory = process.memory_info().rss / 1024 / 1024  # MB
        
        memory_increase = peak_memory - initial_memory
        
        # 内存增长应该合理 (不超过100MB)
        assert memory_increase < 100, f"内存增长过大: {memory_increase:.2f}MB"
```

## 4.4 异常测试

### 4.4.1 网络异常测试

```python
import pytest
from unittest.mock import patch
from src.download_manager import DownloadManager

class TestNetworkExceptions:
    """网络异常测试"""
    
    @pytest.fixture
    def download_manager(self):
        """创建下载管理器"""
        return DownloadManager()
    
    @patch('requests.get')
    def test_connection_timeout(self, mock_get, download_manager):
        """测试连接超时"""
        import requests
        mock_get.side_effect = requests.exceptions.Timeout()
        
        result = download_manager.download_segment(
            "https://example.com/segment.ts",
            "temp.ts"
        )
        
        assert result is False
    
    @patch('requests.get')
    def test_connection_error(self, mock_get, download_manager):
        """测试连接错误"""
        import requests
        mock_get.side_effect = requests.exceptions.ConnectionError()
        
        result = download_manager.download_segment(
            "https://example.com/segment.ts",
            "temp.ts"
        )
        
        assert result is False
    
    @patch('requests.get')
    def test_http_error(self, mock_get, download_manager):
        """测试HTTP错误"""
        import requests
        mock_get.side_effect = requests.exceptions.HTTPError("404 Not Found")
        
        result = download_manager.download_segment(
            "https://example.com/segment.ts",
            "temp.ts"
        )
        
        assert result is False
```

### 4.4.2 文件系统异常测试

```python
import pytest
from src.file_manager import FileManager

class TestFileSystemExceptions:
    """文件系统异常测试"""
    
    @pytest.fixture
    def file_manager(self):
        """创建文件管理器"""
        return FileManager()
    
    def test_invalid_path(self, file_manager):
        """测试无效路径"""
        with pytest.raises(FileNotFoundError):
            file_manager.create_directory("/invalid/path/that/does/not/exist/file.txt")
    
    def test_permission_denied(self, file_manager, tmp_path):
        """测试权限拒绝"""
        # 在Windows上可能需要特殊处理
        try:
            protected_file = tmp_path / "protected.txt"
            protected_file.write_bytes(b"test")
            protected_file.chmod(0o000)
            
            with pytest.raises(PermissionError):
                protected_file.write_bytes(b"new content")
        finally:
            # 恢复权限以便清理
            protected_file.chmod(0o644)
    
    def test_disk_full_simulation(self, file_manager, tmp_path):
        """测试磁盘满模拟"""
        # 创建大文件模拟磁盘满
        large_file = tmp_path / "large.bin"
        
        try:
            # 尝试创建超大文件
            large_file.write_bytes(b"x" * (10 * 1024 * 1024 * 1024))  # 10GB
        except (OSError, MemoryError):
            # 预期的异常
            pass
```

### 4.4.3 配置异常测试

```python
import pytest
from src.config_manager import ConfigManager

class TestConfigExceptions:
    """配置异常测试"""
    
    def test_missing_config_file(self):
        """测试缺少配置文件"""
        with pytest.raises(FileNotFoundError):
            ConfigManager.load("nonexistent.yaml")
    
    def test_invalid_yaml_format(self, tmp_path):
        """测试无效的YAML格式"""
        config_file = tmp_path / "invalid.yaml"
        config_file.write_text("invalid: yaml: content:")
        
        with pytest.raises(Exception):
            ConfigManager.load(str(config_file))
    
    def test_missing_required_field(self, tmp_path):
        """测试缺少必需字段"""
        config_file = tmp_path / "incomplete.yaml"
        config_file.write_text("download:\n  threads: 4")
        
        with pytest.raises(KeyError):
            ConfigManager.load(str(config_file))
```

## 4.5 测试覆盖率要求

### 4.5.1 覆盖率目标

- **单元测试覆盖率**: 不低于80%
- **集成测试覆盖率**: 不低于60%
- **关键模块覆盖率**: 不低于90%

### 4.5.2 覆盖率报告生成

运行测试并生成覆盖率报告:

```bash
# 生成HTML覆盖率报告
pytest --cov=src --cov-report=html

# 生成终端覆盖率报告
pytest --cov=src --cov-report=term-missing

# 生成XML覆盖率报告(用于CI/CD)
pytest --cov=src --cov-report=xml
```

### 4.5.3 覆盖率检查

在CI/CD流程中添加覆盖率检查:

```yaml
# .github/workflows/test.yml
name: Test
on: [push, pull_request]
jobs:
  test:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v2
      - name: Set up Python
        uses: actions/setup-python@v2
        with:
          python-version: '3.8'
      - name: Install dependencies
        run: |
          pip install -r requirements.txt
          pip install pytest pytest-cov
      - name: Run tests with coverage
        run: |
          pytest --cov=src --cov-report=xml --cov-fail-under=80
      - name: Upload coverage
        uses: codecov/codecov-action@v2
        with:
          file: ./coverage.xml
```

## 4.6 测试最佳实践

### 4.6.1 测试命名规范

```python
# 好的测试命名
def test_download_segment_success():
    pass

def test_download_segment_with_retry():
    pass

def test_download_segment_timeout_error():
    pass

# 避免的测试命名
def test1():
    pass

def test_download():
    pass
```

### 4.6.2 测试独立性

每个测试应该独立运行,不依赖其他测试:

```python
class TestIndependentTests:
    """独立的测试"""
    
    def test_case_1(self, tmp_path):
        """测试用例1"""
        file1 = tmp_path / "file1.txt"
        file1.write_text("content1")
        assert file1.exists()
    
    def test_case_2(self, tmp_path):
        """测试用例2 - 不依赖test_case_1"""
        file2 = tmp_path / "file2.txt"
        file2.write_text("content2")
        assert file2.exists()
        # 不检查file1是否存在
```

### 4.6.3 使用Fixture

使用pytest fixture来管理测试资源:

```python
@pytest.fixture
def sample_data():
    """提供测试数据"""
    return {
        "url": "https://example.com/video.m3u8",
        "cookies": {"session": "test123"}
    }

def test_with_fixture(sample_data):
    """使用fixture的测试"""
    assert sample_data["url"].startswith("https://")
    assert "session" in sample_data["cookies"]
```

### 4.6.4 Mock外部依赖

使用mock来隔离外部依赖:

```python
from unittest.mock import Mock, patch

@patch('requests.get')
def test_with_mock(mock_get):
    """使用mock的测试"""
    mock_response = Mock()
    mock_response.status_code = 200
    mock_response.content = b"test"
    mock_get.return_value = mock_response
    
    # 执行测试
    result = download_segment("https://example.com/segment.ts")
    
    assert result is True
    mock_get.assert_called_once()
```
